This is the README for Redirect Manager.

Redirect Manager is a project that I had worked on during my internship at Citrix Systems, Inc during the summer of 2017 (May 2017 - July 2017) with direct help from Phani Jasthi (https://www.linkedin.com/in/phanijasthi/) and Raghu Varma (). 

This was written in Node.JS, and this is the source code for it. In order to fully implement the project, Jira, Apache and Chef software are also utilized. 

Overview of the software:
	
	Redirect Manager is a tool that automates the process of creating a redirect. 

	As mentioned earlier, Jira, Apache and Chef software was used in the process of making the Redirect Manager go live for use by other memebers within the company for the Digital Marketing team. These will be covered in detail below.

Jira: 
	
	The first step is using this code is making sure that you have a Jira board that it can connect to. On top of being the tool where a user creates the tickets to submit a redirect request, the Jira board is also the source of truth for the redirects that are currently live on the web, while giving other functionality on top of that as well. I will go in depth about the set up we used during my internship in order to help with such process in case that it is needed.

	Jira is a software created by the developers at Atlassian. A nice software to use for multiple purposes as the boards that they allow you to create can extend beyond this Redirect Manager if you had not known already. As a result, there are tutorials that Atlassian has in order to help with the creation of a Jira board (nice starting point: https://confluence.atlassian.com/agile/jira-agile-user-s-guide/creating-a-board).

	With that said, for our set up, we had 4 statuses that were part of the workflow. The 4 statuses that we used were called Open, Push, Live and Sunset. On the board, we only show the statuses Open, Push and Live while keeping Sunset hidden. Now, when a new ticket is created, a form should pop up asking for relevant information related to the redirect request that is about to be created. In our setup, the fields we use are named Summary, Redirect From for the source URL that the redirect will happen from, Redirect To for the final destination URL that the Redirect From will go to, Start Date for the date a person wants the redirect to go live, and End Date for when a user wants the redirect to be pulled from the web. There are other sections that are more self-explanatory. Check the screenshots folder for an example of our form (the file name is "FormExample.png"). As you will see, there are hints that state for the Redirect From that all URLs must be relative. For our implementation, all redirects were to happen from internal sites for the company. The code base can be only changed in order to implement your own companies assets and needs for that section. With that being said, I shall remind that this project pertains to solutions needed for the company, and is not a 100% general solution to uploading redirects. This source code simply gives a good starting point in order to be implemented for use if need be by others. Moving on from that, once a ticket is done and all the fields are filled out, the user then hits the create button. For our implementation, we send the created ticket to the Push status. It as at this step that a webhook is triggered that connects to the NodeJs app, the source code given in this repo, and is run. It is at this point the backend validations occur. This is handled mainly within the JiraController file. If validations need to be changed for your company, I would suggest doing those changes there. If a ticket fails validations, then it will go to the Open status where the program writes a comment on the ticket stating why it failed. Once the changes are made and the ticket has been properly edited, then a person must trantision that corrected ticket back to the open status in order so validation checks can be run again. If validations pass, then the program will write that the ticket has passed validation checks. It is at this point that the ticket waits for the cron job toLiveJob() to run. This is what sends proper tickets to the live status. On top of that, there is another cron job that runs called sunsetJob(). This one checks for end dates to see if a ticket has expired and move to the Sunset status so that the ticket and its corresponding redirect no longer exist. This gives the overview for the statuses and how they work.

	For the transitions, we had one for Open to Push, Push to Live, Live to Sunset, Live to Open. You can add more transitions if you want for whichever status-to-status you want. The transitions are key. The reason being this is where webhooks are set. In the above paragraph, I spoke on the webhooks a bit. Basically, a webhook listens for certain events, and once the webhooks are triggered due to that event, it triggeres another event at a location listening to the webhook for certain code to run (here's a better explanation: https://webhooks.pbworks.com/w/page/13385124/FrontPage). During testing, Ngrok was our best friend. Here's a link for what ngrok is about: (https://ngrok.com/). Basically, ngrok gives you a link that listens for webhooks and sends the post to the program so that the code can be run. To use ngrok, you simply put the executable in a place you can always find and on a terminal, run "./ngrok http 'port number'", where 'port number' is where you want to ngrok to listen to. So if you want ngrok to listen to your 3000 port, you'd write "./ngrok http 3000". It is through this that validation steps were able to occur because we set a webhook on the transition from Open to Push status so validation could take place. Now if you read the previous paragraph, you may remember the mention that when a ticket is created, it starts off by directly starting in the Push status. When we implemented this, we realized that the webhook for Open to Push was no longer triggered. As a result, we needed to find a work around so that the validation gets triggered for the newly created ticket. In truth, Raghu Varma, mentioned in the beginning, handled this workaround, so I do not know of his exact solution towards it. Regardless, your Jira board does not have to follow ours. It's simply a skeleton for your implementation. 






